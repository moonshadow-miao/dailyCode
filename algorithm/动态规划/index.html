<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"></head><body></body></html>

<script>
    // 汉诺塔问题
    function hanoi(n) {
      function process(n, left, right, help) {
        if(n === 0) return 0
        const time1 = process(n - 1, left, help, right)
        console.log(`第${n}层： 从${left}移动到${right}`)
        const time2 = process(n - 1, help, right, left)
        return time1 + time2 + 1
      }
      return process(3, 'left', 'right', 'help')
    }

    function getStackBottom (stack) {
      let node = stack.pop()
      if (stack.isEmpty()) {
        return node
      }
      const returnNode = getStackBottom(stack)
      stack.push(node)
      return returnNode
    }

    // 翻转栈
    function revertStack(stack) {
      if (stack.isEmpty()) {
        return
      }
      let node = getStackBottom(stack)
      revertStack(stack)
      stack.push(node)
    }

    // 机器人问题，从数组一个位置移动到另外一个位置，必须要走target步数，每次可以往左右移动一步，但是在数组收尾位置只能向数组内部移动
    // 求解：有多少种走法
    function robotMove(nums, start, target, steps) {
      const dp = Array(steps + 1).fill('').map(() => [])
      dp[0] = Array(nums.length).fill(0).map((_, index) => index === target ? 1 : 0)
      for(let i = 1; i <= steps; i++) {
        for(let j = 0; j < nums.length; j++) {
          if (target - j > i) {
            dp[i][j] = 0
            continue
          }
          if (j === 0) {
            dp[i][j] = dp[i -1][1]
            continue
          }
          if (j === nums.length - 1) {
            dp[i][j] = dp[i -1][nums.length - 2]
            continue
          }
          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        }
      }
      return dp[steps][start]
    }

    console.log(robotMove([0, 1, 2, 3, 4, 5, 6, 7, 8], 1, 3, 4))

</script>
